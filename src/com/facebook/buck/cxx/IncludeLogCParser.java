/*
 * Copyright 2015-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.cxx;

import com.facebook.buck.io.MorePaths;
import com.facebook.buck.util.Escaper;
import com.google.common.base.Preconditions;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Optional;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import javax.annotation.Nullable;

class IncludeLogCParser {

  /**
   * No official documentation exists for this format.  Only docs are here (find `-dCHARS`):
   * https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html
   *
   * If a line matches, captured groups are:
   * 'token' for the inclusion token without the '#'; and 'contents' which has the included file and
   * does include the surrounding double-quotes or angle brackets.
   */
  private static final Pattern INCLUSION_PATTERN = Pattern.compile(
      "^#(?<token>(include|import|include_next|__include_macros)) *" +
      "(?<contents>((<([^>\n]+)>)|(\"([^\"\n]+)\"))).*$");

  /**
   * Line markers generated by preprocessor.  See:
   * https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html
   *
   * If a line matches, captured groups are 'path' for the current filename, including escapes
   * (but not quotes), and 'flags' for zero or more space-separated numeric codes (maybe >1 space
   * between them), see above link.
   */
  private static final Pattern LINE_MARKER_PATTERN = Pattern.compile(
      "^# +[0-9]+ +\"(?<path>(\\\\|\\\"|[^\"\n])+)\"(?<flags>( *[0-9]+)*)$");

  /** Current line number (while parsing).  Mainly used for error reporting. */
  private int lineCounter = 0;

  /** Last line read (while parsing). Mainly used for error reporting. */
  @Nullable
  private String line = null;

  /** ID number of the next IncludeLogEntry to be created (bumped on each use). */
  private int nextEntryID = 0;

  private int getNextEntryID() {
    return ++nextEntryID;
  }

  /** Begin parsing the preprocessed C/C++ code, provided by this reader. */
  public IncludeLogCParser parse(final Reader reader) {
    // Construct line-wise reader, make initial jump into the recursive parse function.
    // Gracefully handle errors (nicer output, wrap into RuntimeException).
    try (BufferedReader bufferedReader = new BufferedReader(reader)) {
      parse(bufferedReader, null, null);
      return this;
    } catch (IOException | RuntimeException e) {
      throw new RuntimeException(
          String.format("error at line [%d]; line was [%s]", lineCounter, line), e);
    }
  }

  /** Mapping of id => IncludeLogEntry with that id. */
  private final SortedMap<Integer, IncludeLogEntry> entryTable = new TreeMap<>();

  public SortedMap<Integer, IncludeLogEntry> getEntryTable() {
    return this.entryTable;
  }

  private void addEntry(IncludeLogEntry entry) {
    this.entryTable.put(entry.id(), entry);
  }

  /**
   * is it a bogus, faux-file such as "<built-in>"?  Strip these chars, invalid on some OSes.
   */
  private String scrubPathString(String in) {
    StringBuilder cleanPathBuilder = new StringBuilder();
    for (char c : in.toCharArray()) {
      if (// weird ASCII control codes, including NUL; filter them
          (c < ' ') ||
          // non-comprehensive set of invalid Windows chars
          ("<>:|\"".indexOf(c) != -1)) {
        c = '_';
      }
      cleanPathBuilder.append(c);
    }

    return cleanPathBuilder.toString();
  }

  /**
   * Recursive parse function.
   * @param parent the entry built upon seeing the inclusion, the target of which was the includer
   *        of futures includes encountered.  This is {@code null} iff this is at the top-level,
   *        i.e. the current file is the translation unit.
   */
  private void parse(
      final BufferedReader reader,
      @Nullable final IncludeLogEntry parent,
      @Nullable final Path currentFile) throws IOException {

    /* parsing state */
    IncludeLogEntry.InclusionKind inclusionKind = null;
    IncludeLogEntry.QuoteKind quoteKind = null;
    String parameter = null;
    Path nextFile = null;

    // Try to consume all lines in the input.  Only handle '#' (preprocessor) lines.
    while ((line = reader.readLine()) != null) {
      lineCounter++;
      line = line.trim();
      if (!line.startsWith("#")) {
        continue;
      }

      Matcher includeMatch = INCLUSION_PATTERN.matcher(line);
      if (includeMatch.matches()) {
        String contents = includeMatch.group("contents");
        inclusionKind = determineIncludeKind(includeMatch.group("token"));
        quoteKind = (contents.charAt(0) == '<')
                    ? IncludeLogEntry.QuoteKind.ANGLE
                    : IncludeLogEntry.QuoteKind.QUOTE;
        parameter = scrubPathString(contents.substring(1, contents.length() - 1));
        continue;
      }

      Matcher lineMarkerMatch = LINE_MARKER_PATTERN.matcher(line);
      if (lineMarkerMatch.matches()) {
        Set<Integer> flags = parseFlags(lineMarkerMatch.group("flags"));

        String path = Escaper.unescapeLineMarkerPath(lineMarkerMatch.group("path"));
        path = scrubPathString(path);

        // Path obj representation of the include parameter.  (Not checked for validity/existence)
        nextFile = MorePaths.fixPath(Paths.get(path));

        if (flags.contains(1)) {
          // flag #1 indicates we're entering a new file.
          Preconditions.checkNotNull(currentFile);
          IncludeLogEntry entry;

          // inclusionKind is null IFF there hasn't been an #include or other inclusion prior to
          // having entered this file.  In that case, it's a builtin, predefined, etc. header.
          if (inclusionKind == null) {
            inclusionKind = IncludeLogEntry.InclusionKind.BUILTIN;
            quoteKind = IncludeLogEntry.QuoteKind.NONE;
            parameter = path;
          }

          // At this point all these items should have been set.
          Preconditions.checkNotNull(currentFile);
          Preconditions.checkNotNull(quoteKind);
          Preconditions.checkNotNull(parameter);
          Preconditions.checkNotNull(nextFile);

          // Build and stash this new record.
          entry = IncludeLogEntry.of(
              getNextEntryID(),
              Optional.ofNullable(parent),
              currentFile,
              inclusionKind,
              quoteKind,
              parameter,
              nextFile);
          addEntry(entry);

          // Recurse into this new file.
          parse(reader, entry, nextFile);

          // Clear state about this include, to prepare for the next one.
          inclusionKind = null;
          quoteKind = null;
          parameter = null;
          nextFile = null;
        } else if (flags.contains(2)) {
          // flag #2 indicates a return to included after a completed include.
          Preconditions.checkNotNull(parent, "number of file entry/exit flags unmatched");
          // Bounce back up to the parent context.
          return;
        } else {
          // Treat as a standard line marker showing line number + file.
          // (Might have flags we don't care about: 3 => system include, 4 => "extern C", ...)
          if (currentFile == null) {
            // Recurse to re-enter with a new set of invariants (not modifiable b/c "final").
            parse(reader, parent, nextFile);
            return;
          }
        }

        continue;
      }
    }

    // reached end of 'while' loop: no more lines.
    Preconditions.checkState(parent == null, "unexpected EOF");
    return;
  }

  protected static SortedSet<Integer> parseFlags(String flags) {
    TreeSet<Integer> ret = new TreeSet<>();
    for (String flag : flags.split(" ")) {
      flag = flag.trim();
      if (flag.length() > 0) {
        ret.add(Integer.parseInt(flag));
      }
    }
    return ret;
  }

  protected static IncludeLogEntry.InclusionKind determineIncludeKind(String token) {
    switch (token) {
      case "include":
        return IncludeLogEntry.InclusionKind.INCLUDE;
      case "include_next":
        return IncludeLogEntry.InclusionKind.INCLUDE_NEXT;
      case "import":
        return IncludeLogEntry.InclusionKind.IMPORT;
      case "__include_macros":
        return IncludeLogEntry.InclusionKind.INCLUDE_MACROS;
      default:
        throw new IllegalArgumentException("unknown inclusion kind: " + token);
    }
  }

}
